#! /usr/bin/env bash
set -o pipefail

# STDIN Input should be an array of objects (NOT ndjson)

display_key="$1"
shift
# TODO: allow multi display key, all args before -- are display keys, then preview keys after

preview_key="$1"
shift

declare -A choiceDict
while IFS=$'\t' read -r key value; do
  choiceDict["$key"]="$value"
done < <(jq -r --arg displayKey "$display_key" '.[] | [.[$displayKey], (. | @json)] | @tsv')

if [[ "${#choiceDict[@]}" -eq 0 ]]; then
  echo "No choices found" >/dev/stderr
  exit 1
fi

fullset=$(mktemp)
for x in "${!choiceDict[@]}"; do echo "${choiceDict["$x"]}"; done | jq -s -c | sponge "$fullset"

tmpscript=$(mktemp)
cat <<___EOF >>"$tmpscript"
#! /usr/bin/env bash
jq -r --arg tgtVal "\$1" '.[] | select(.["$display_key"] == \$tgtVal) | .["$preview_key"]' "$fullset"

___EOF

chmod +x "$tmpscript"
# COULDDO: add fzf bindings to scroll, and to modify command e.g to just show json keys
selection=$(for x in "${!choiceDict[@]}"; do echo "$x"; done | fzf ${JM_FZF_JSON_OPTS:-} --preview="$tmpscript "'{}')

if [[ -z $selection ]]; then
  echo "No selection" >/dev/stderr
  exit 1
fi

for x in $(xargs -n 1 -0 <<<"${selection[@]}"); do
  echo "${choiceDict["$x"]}"
done
