#!/usr/bin/env bash

set -euo pipefail
use_debug_mode=""
if ! [ -z "${S_DEBUGGER:-""}" ]; then
    use_debug_mode="1"
fi

if [ -n "$use_debug_mode" ]; then
    set -x
fi

# dir=$SCRIPTS_DIR_ROOT

execution_tracker="$HOME/.local/scripts-dir-metrics/$(date +%F)"
s_script_path=""

deadEndDirs=()

orig_args=("$@")

IS_TOPLEVEL_CALL=$(if [[ -z ${S_INNER_CALL:-""} ]]; then echo 1; else echo 0; fi)
export S_INNER_CALL=1

checkScriptDir() {
    dir="$1"
    shift
    while [[ $# -gt 0 ]]; do
        command="$1"

        metrics_dir_path="$execution_tracker$dir/$command"

        shift
        if [[ -d "$dir/$command" ]]; then
            dir="$dir/$command"
        elif [[ -f "$dir/$command" ]]; then
            if [[ -x "$dir/$command" ]]; then
                # recording metrics on how often they are used
                mkdir -p "$metrics_dir_path/"{executions,invocations}
                runid=$(uuidgen)

                if [[ $IS_TOPLEVEL_CALL -eq 1 ]]; then
                    set +e
                    # TODO get the id back here to tie it to executions
                    jo ts="$(date)" id="$runid" ts="$(date)" command="$dir/$command" args="${orig_args[@]}" | sqlite-utils insert --alter --pk id $SCRIPTS_LOCAL_DIR/s-scripts-meta.db invocations -
                    set -e
                fi
                if [[ -f "$dir/$command.inproc" ]]; then
                    source "$dir/$command" "$@"
                elif [[ -f "$dir/$command.direnv" ]]; then
                    direnv exec $dir "$dir/$command" "$@"
                elif [ -n "$use_debug_mode" ]; then
                    bash -x "$dir/$command" "$@"
                else
                    "$dir/$command" "$@"
                fi
                if [[ $IS_TOPLEVEL_CALL -eq 1 ]]; then
                    set +e
                    jo ts="$(date)" id="$runid" command="$dir/$command" args="${orig_args[@]}" | sqlite-utils insert --alter --pk id $SCRIPTS_LOCAL_DIR/s-scripts-meta.db executions -
                    set -e
                fi
                exit 0
            fi
        fi
    done
    deadEndDirs+=("$dir")
}

no_commands=1
for scriptdir in $(echo "$SCRIPTS_PATH" | tr ':' '\n'); do
    checkScriptDir "$scriptdir" "${orig_args[@]}"
done
set +x

# TODO if deadEndDirs has length
# do below
# if [[ -e "$dir.help" ]]; then
#     cat "$dir.help" > /dev/stderr
#     echo
# else
#     command=$(basename "$dir")
#     echo "$command commands" > /dev/stderr
#     echo
# fi

# # for file in $(find "$dir" -maxdepth 1 -mindepth 1 -exec test -x {} \; -print); do
# #     command=$(basename "$file")
# #     helpfile="$file.help"
# #     if [[ -f "$helpfile" ]]; then
# #         help=$(head -n1 "$helpfile")
# #     elif [[ -d "$file" ]]; then
# #         help="$command commands"
# #     else
# #         help=$(sed -nE -e '/^#!/d' -e '/^#/{s/^# *//; p; q;}' "$file")
# #     fi
# #     # this should really be a two-pass thing to calculate
# #     # the longest filename instead of hardcoding the spacing...
# #     # but oh well whatever
# #     if [[ -d "$file" ]]; then
# #         command="$command ..."
# #     fi
# #     printf '%-10s -- %s\n' "$command" "$help"
# #     no_commands=0
# # done

if [[ "$no_commands" -eq 1 ]]; then
    echo "(no subcommands found)"
    exit 1
fi
